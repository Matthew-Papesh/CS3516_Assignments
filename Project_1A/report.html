<!DOCTYPE html>
<html>
<head>
<title>report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="project-1a-report"><strong>Project 1A Report</strong></h1>
<h3 id="matthew-papesh---feb-3rd-2025">Matthew Papesh - Feb 3rd, 2025</h3>
<h3 id="cs-3516">CS 3516</h3>
<h2 id="overview">Overview:</h2>
<p>The objective of this assignment was to explore and implement TCP and UDP protocols in python for communication between a given client and server.</p>
<p>Transmission Protocol Standard [TCP] allows for the communication of data packets across a sending and receiving device given specified host names for targets at specified port entry points on known internet networks. TCP also is a reliable means of communicating as it transmits from a client device to a server such that the server will communicate back to the client that it as received its message. This is also good for error correction as lost or corrupted data packets can be communicated back to client and re-transmitted.</p>
<p>User Datagram Protocol [UDP] allows for the communication of data packets across a sending and receiving device given specified receiving server host name and network entry point port on the sending client side. UDP is received by a server expecting or checking for transmissions from a given client given a pre-determined and known client host and network entry point port. However, the server only connects to the client temporarily and only upon receiving any potential transmitted data packets before disconnecting. UDP does not transmit from the server back to the client to insure the reliability of data packets. Unlike TCP that does this re-transmission, UDP does not. However, UDP may be faster with a smaller latency overhead as a result.</p>
<p>TCP and UDP are used for different purposes. TCP is ideal for when data reliability is a must, and UDP is emphasized for when minimal latency is demanded. Examples of this is that TCP is good for sending emails or downloading websites when exploring the internet by http protocols. Where data accuracy is required. Meanwhile video calls and other live forms of communication can come in the form of UDP since staying live and not slowing down is needed; and if the video slightly glitches once in a one hour call from some erroneous data packets transmitted, then that is fine.</p>
<h2 id="tcp-implementation">TCP Implementation:</h2>
<p>TCP was implemented in python by use of the socket library on local host with a network entry point port of 8450. Sockets also transmit an expected buffer size of 1024 bits. A socket is opened client-side and server-side files (<strong>tcp_client.py, tcp_server.py</strong>) by calling <code>socket.socket()</code> where <code>socket.AF_INET</code> is used for indicating allowable internet protocols for communication while <code>socket.SOCK_STREAM</code> is specified for indicating the use of a TCP protocol.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># server-side TCP - opening communication </span>
<span class="hljs-comment"># open communication via tcp</span>
<span class="hljs-keyword">with</span> s.socket(s.AF_INET, s.SOCK_STREAM) <span class="hljs-keyword">as</span> tcp_socket:
	<span class="hljs-comment"># enter specified entry point port and listen</span>
	<span class="hljs-keyword">try</span>:
		tcp_socket.bind((host, port))
		print(<span class="hljs-string">"Binded to "</span> + str(host) + <span class="hljs-string">":"</span> + str(port))
	<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
		print(<span class="hljs-string">f"Error binding to socket: <span class="hljs-subst">{e}</span>"</span>)
	print(<span class="hljs-string">"Server has began listening..."</span>)
	tcp_socket.listen()
	print(<span class="hljs-string">"Server is still listening..."</span>)
	<span class="hljs-comment"># confirm connection</span>
	connection, address = tcp_socket.accept()
</div></code></pre>
<p>The socket on client-side first connects to a given server host and port. The client then spins collecting user input from the terminal that is then encoded to be sent to the server over TCP by use of the <code>sendall()</code> method. The client then receives data back from the server and is printed on the client. If the user input ever is <code>exit</code>, the client terminates.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># open communication via tcp</span>
<span class="hljs-keyword">with</span> s.socket(s.AF_INET, s.SOCK_STREAM) <span class="hljs-keyword">as</span> tcp_socket:
	<span class="hljs-comment"># connect to specified entry point port on server network</span>
	tcp_socket.connect((host, port))
	<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
		<span class="hljs-comment"># transmit data from input</span>
		msg = input(<span class="hljs-string">"transmitting msg: "</span>)
		tcp_socket.sendall(msg.encode()) <span class="hljs-comment"># encode data</span>
		<span class="hljs-comment"># end client if told to exit</span>
		<span class="hljs-keyword">if</span> msg == <span class="hljs-string">"exit"</span>:
			print(<span class="hljs-string">"exiting; ending service..."</span>)
			<span class="hljs-keyword">break</span>
		<span class="hljs-comment"># retrieve returned message from tcp 10240bit buffer size</span>
		data = tcp_socket.recv(<span class="hljs-number">1024</span>)
</div></code></pre>
<p>The socket on the server-side binds to the specified client host and entry port. The server begins to listen for transmissions from the client before accepting connection and client address. The server opens the connection, receives data by use of the <code>recv()</code> method and then prints the transmitted data. The server then sends the data back to the client. If a transmission is received without data, the server assumes the client as terminated and it to also exits and terminates.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># confirm connection</span>
connection, address = tcp_socket.accept()
<span class="hljs-comment"># open connection and listen/receive data by tcp</span>
<span class="hljs-keyword">with</span> connection:
	print(<span class="hljs-string">"Connected TCP socket by address: "</span> + str(address))
	<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
		<span class="hljs-comment"># listen for tcp data of 1024-bit buffer size</span>
		data = connection.recv(<span class="hljs-number">1024</span>)
		<span class="hljs-comment"># contribute hosting server-side tcp as long as</span>
		<span class="hljs-comment"># client is still using service (not data == False)</span>
		<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:
			<span class="hljs-keyword">break</span>
		<span class="hljs-comment"># return data to client</span>
		print(<span class="hljs-string">"Sending data back to client: data == "</span> + str(data))
		connection.sendall(data)
    <span class="hljs-comment"># print data</span>
	print(<span class="hljs-string">"Received data: "</span> + str(data))
</div></code></pre>
<h2 id="udp-implementation">UDP Implementation:</h2>
<p>UDP was implemented in python by use of the socket library on local host with a network entry point port of 8451. Sockets also transmit an expected buffer size of 1024 bits. A socket is opened client-side and server-side files (<strong>udp_client.py, udp_server.py</strong>) by calling <code>socket.socket()</code> where <code>socket.AF_INET</code> is used for indicating allowable internet protocols for communication while <code>socket.SOCK_DGRAM</code> is specified for indicating the use of UDP protocol.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># server-side UDP - opening communication </span>
<span class="hljs-keyword">with</span> s.socket(s.AF_INET, s.SOCK_DGRAM) <span class="hljs-keyword">as</span> udp_socket:
	<span class="hljs-comment"># enter specified entry point port and bind</span>
    <span class="hljs-keyword">try</span>:
	    udp_socket.bind((host, port))
    	print(<span class="hljs-string">"Bounded to "</span> + str(host) + <span class="hljs-string">":"</span> + str(port))
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
	    print(<span class="hljs-string">f"Error binding to socket: <span class="hljs-subst">{e}</span>"</span>) 
</div></code></pre>
<p>The socket on the client-side does not initially connect to the server, but instead begins spinning instead to await user input. User input is encoded and then send over the socket by also specifying the server host and port at this time only. Data is then sent over to the server by UDP by use of the <code>sendto()</code> method, where not only is the data required, but so is the destination. If the user input ever is <code>exit</code>, the client terminates.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># open communication via udp</span>
<span class="hljs-keyword">with</span> s.socket(s.AF_INET, s.SOCK_DGRAM) <span class="hljs-keyword">as</span> udp_socket:
	<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
		<span class="hljs-comment"># input data from user</span>
		msg = input(<span class="hljs-string">"transmitting msg: "</span>)
		<span class="hljs-comment"># end client if told to exit</span>
		<span class="hljs-keyword">if</span> msg == <span class="hljs-string">"exit"</span>:
			print(<span class="hljs-string">"exiting; ending service..."</span>)
			<span class="hljs-keyword">break</span>
		<span class="hljs-comment"># temporarily connect for single transmission by udp</span>
		udp_socket.sendto(msg.encode(), (host, port))
</div></code></pre>
<p>The socket on the server-side binds to the specified client host and entry port. The server begins by immediately spinning and awaits data packets sent from the expected client. The server does not connect to the client until when checking for received data by use of the <code>recvfrom()</code> method, where not only is the data returned, but so is the client address to identify the sender. The server then prints the retrieved data but does not transmit back to the client. The client assumes or does not know if the server has received its transmissions.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># open connection by udp</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
	<span class="hljs-comment"># retrieve any received data from various clients by address</span>
	data, address = udp_socket.recvfrom(<span class="hljs-number">1024</span>)
	print(<span class="hljs-string">"Received from client "</span> + str(address) + <span class="hljs-string">": "</span> + str(data))
</div></code></pre>
<h2 id="conclusion">Conclusion:</h2>
<p>TCP and UDP are similar and yet different in many ways. TCP may be more reliable over UDP for data transmission, but UDP may have less latency and overhead over TCP. It is worth noticing how connections need to be bounded on both protocols, but TPC client connects as initialization to communication while UDP client only connects upon sending transmissions. TCP servers listen and accept connections to clients as initialization to receiving communication while UDP servers may not always initially know where transmissions come from. Moreover, it makes sense how TCP servers only return the data when receiving transmissions, but UDP servers also return the address of origin of the transmission.</p>
<div class="row" style="display: flex; flex-direction: row; justify-content: center; align-items: center;">
	<div class="column">
		<img src="./images/TCP_ServerSide.png" alt="tcp-server-side-comms" style="width:100%; height:auto;">
	</div>
	<div class="column">
		<img src="./images/TCP_ClientSide.png" alt="tcp-client-side-comms" style="width:100%; height:auto;">
	</div>
</div>
<p>The above is a demonstration of the python TCP protocol using the socket library. Three transmissions are communicated over the client [right-side] to the server [left-side]. Messages being: 'b'initial_transmit', 'b'we_love_TCP', and 'b'final_msg'. The server also shows the local host of the client along with the entry point port of the connection. The communication ends with <code>exit</code> being sent and the client terminates with the server following shortly behind. Finally, it is worth noticing how the TCP server returns the data back to the client as well.</p>
<div class="row" style="display: flex; flex-direction: row; justify-content: center; align-items: center;">
	<div class="column">
		<img src="./images/UDP_ServerSide.png" alt="udp-server-side-comms" style="width:100%; height:auto%;">
	</div>
	<div class="column">
		<img src="./images/UDP_ClientSide.png" alt="udp-client-side-comms" style="width:100%; height:auto:">	
	</div>
</div>
<p>The above is a demonstration of the python UDP protocol using the socket library. Three transmission are communicated over the client [right-side] to the server [left-side]. Message being: 'b'intial_message', 'b'we_like_UDP', and 'b'final_transmit'. The server also shows the local host of the client along with the entry point port of the connection. The communication ends with <code>exit</code> being sent and the client terminates with the server continuing to run and spin/idle. Finally, it is worth noticing how the UDP server does not return anything to the client as per UDP format.</p>
<p>Overall, the implementations were similar, but were both designed with different uses in mind. The code was also designed with print statements and exception handling for debugging purposes.</p>

</body>
</html>
